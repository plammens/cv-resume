import datetime
import functools
import logging
import os
from abc import ABCMeta, abstractmethod
from typing import ClassVar, Dict, IO, Optional, Type

import yaml

from .config import DATE_FIELDS, FORMATS, ITEMS_FIELD, ROOT_OUTPUT_PATH, TEXT_FIELDS
from .save import save_tex
from .templates import TEX_TEMPLATES
from .tokenize import tokenize
from .utils import (
    Data,
    FormattedFields,
    Formatter,
    format_date_long,
    format_date_short,
    format_optional,
    parse_date,
)


logger = logging.getLogger(__name__)


class AbstractTexModuleGenerator(metaclass=ABCMeta):
    def __init__(self, module_type: str, formatters: Dict[str, Formatter] = None):
        if formatters is None:
            formatters = {fmt: getattr(self, f"format_fields_{fmt}") for fmt in FORMATS}

        self.module_type = module_type
        self.formatters = formatters

    @abstractmethod
    def read(self, source: IO) -> Data:
        pass

    @abstractmethod
    def parse(self, data: Data) -> Data:
        pass

    @abstractmethod
    def generate(self, parsed_data: Data, fmt: str) -> str:
        pass

    @abstractmethod
    def save(self, generated_tex: str, *, name: str, fmt: str):
        pass

    def format_base(self, parsed_data: Data) -> FormattedFields:
        return parsed_data.copy()

    def format_fields_cv(self, data: Data) -> FormattedFields:
        formatted = self.format_base(data)

        for date_field in DATE_FIELDS:
            if date_field in data:
                formatted[date_field] = format_date_long(data[date_field])

        return formatted

    def format_fields_resume(self, data: Data) -> FormattedFields:
        formatted = self.format_base(data)

        for date_field in DATE_FIELDS:
            if date_field in data:
                formatted[date_field] = format_date_short(data[date_field])

        if "description" in formatted:
            formatted.setdefault("short-description", formatted["description"])

        return formatted


class FileToFileGenerator(AbstractTexModuleGenerator, metaclass=ABCMeta):
    def __init__(
        self,
        module_type: str,
        formatters: Dict[str, Formatter] = None,
        subdir: Optional[str] = None,
    ):
        super().__init__(module_type, formatters)
        self.subdir = subdir if subdir is not None else self.module_type

    def save(self, generated_tex: str, *, name: str, fmt: str):
        save_tex(
            generated_tex,
            type_name=f"{fmt} TeX",
            name=name,
            output_dir=os.path.join(ROOT_OUTPUT_PATH, fmt, self.subdir),
        )

    def generate_file(self, path, add_comment=True):
        """Generate single file"""
        name = os.path.basename(path).rsplit(".")[0]
        logger.debug("%s processing %s (%s)", self.__class__.__name__, name, path)
        with open(path, encoding="utf-8") as f:
            data = self.parse(self.read(f))
        for fmt in self.formatters:
            tex = self.generate(data, fmt)
            if add_comment:
                tex = f"% generated by {__file__} at {datetime.datetime.now()}\n" + tex
            self.save(tex, name=name, fmt=fmt)

    def generate_dir(self, source_dir: str, **kwargs) -> None:
        """Generate all files in a directory"""
        for file_name in os.listdir(source_dir):
            if os.path.isfile(path := os.path.join(source_dir, file_name)):
                self.generate_file(path, **kwargs)


class YamlTexModuleGenerator(FileToFileGenerator, metaclass=ABCMeta):
    item_type: ClassVar[str]

    def __init__(
        self, *, formatters: Dict[str, Formatter] = None, subdir: Optional[str] = None
    ):
        super().__init__(
            module_type=self.item_type, formatters=formatters, subdir=subdir
        )

    def read(self, source):
        return yaml.full_load(source)

    def generate(self, parsed_data: Data, fmt: str) -> str:
        formatter = self.formatters[fmt]
        template = TEX_TEMPLATES[self.module_type][fmt]
        tex = template.fill(formatter(parsed_data))
        return tex

    def parse(self, data: Data) -> Data:
        parsed = data.copy()
        fields = set(data.keys())
        for date_field in DATE_FIELDS & fields:
            parsed[date_field] = parse_date(data[date_field])
        for text_field in TEXT_FIELDS & fields:
            text = data[text_field]
            parsed[text_field] = tokenize(text) if text else None
        return parsed

    def format_base(self, parsed_data: Data) -> FormattedFields:
        parsed_data = parsed_data.copy()
        parsed_data.setdefault("comment", None)
        formatted = super().format_base(parsed_data)
        # replace None with empty string:
        for key, value in parsed_data.items():
            if value is None:
                formatted[key] = ""
        return formatted


def single_file_multiple_items(cls: Type[YamlTexModuleGenerator]):
    """
    Decorate a one-item-per-file generator into a multiple-items-per-file generator

    The generated output consists of the concatenation of the generated output for
    each individual item.
    """

    class DecoratedClass(YamlTexModuleGenerator):
        item_type = cls.item_type

        def __init__(self, *args, **kwargs):
            self.wrapped_generator = cls(*args, **kwargs)
            formatters = {
                fmt: lambda data: {
                    ITEMS_FIELD: [formatter(item) for item in data[ITEMS_FIELD]]
                }
                for fmt, formatter in self.wrapped_generator.formatters.items()
            }
            super().__init__(
                formatters=formatters,
                subdir="",  # single file for all items
            )

        def parse(self, data: Data) -> Data:
            items = data[ITEMS_FIELD]
            return {ITEMS_FIELD: [self.wrapped_generator.parse(item) for item in items]}

        def generate_dir(self, source_dir: str, **kwargs) -> None:
            raise TypeError(f"{cls.__name__} is a single-file-multiple-items generator")

    functools.update_wrapper(DecoratedClass, cls, updated=())
    return DecoratedClass


# ---------------- concrete subclasses -------------------


class ContactInfoGenerator(YamlTexModuleGenerator):
    item_type = "contact-info"

    def __init__(self):
        super().__init__(subdir="")

    def parse(self, data: Data) -> Data:
        return data


@single_file_multiple_items
class SkillsGenerator(YamlTexModuleGenerator):
    item_type = "skill"


class CompactSkillsGenerator(SkillsGenerator):
    item_type = "skill-compact"

    def save(self, generated_tex: str, *, name: str, fmt: str):
        super().save(generated_tex, name=f"{name}-compact", fmt=fmt)


@single_file_multiple_items
class LanguagesGenerator(YamlTexModuleGenerator):
    item_type = "language"

    FRAMEWORK_LINKS = {
        "CEFR": "https://www.coe.int/en/web/common-european-framework-reference-languages/level-descriptions"
    }

    def format_base(self, parsed_data: Data) -> FormattedFields:
        formatted = super().format_base(parsed_data)

        level = parsed_data["level"]

        name = (
            rf"\href{{{link}}}{{ {framework} {level['name']} }}"
            if (link := self.FRAMEWORK_LINKS.get(framework := level.get("framework")))
            else f"{level['name']}"
        )
        level_fmt = name
        if level.get("certificate"):
            level_fmt += rf" (\textit{{{level['certificate']}}})"

        formatted["level"] = level_fmt

        return formatted


class EducationItemGenerator(YamlTexModuleGenerator):
    item_type = "education"

    def format_base(self, parsed_data: Data) -> FormattedFields:
        formatted = super().format_base(parsed_data)

        grade = parsed_data.get("grade")
        formatted["grade"] = (
            rf"\textit{{ {grade['type']}: {grade['value']} }}" if grade else ""
        )

        return formatted

    def format_fields_cv(self, data: Data) -> FormattedFields:
        formatted = super().format_fields_cv(data)

        formatted["degree"] = format_optional(data["degree"])

        comment = data["comment"]
        formatted["comment"] = (
            f"Expected graduation: {comment['expected-end-date']}"
            if comment["expected-end-date"]
            else comment["other"] or ""
        )

        return formatted

    def format_fields_resume(self, data: Data) -> FormattedFields:
        formatted = super().format_fields_resume(data)

        formatted["degree"] = format_optional(data["degree"])

        comment = data["comment"]
        formatted["comment"] = (
            f"(exp. {comment['expected-end-date']})"
            if comment["expected-end-date"]
            else f"({comment['other']})"
            if comment["other"]
            else ""
        )

        institution = data["institution"]
        formatted["institution"] = (
            rf" \newline {institution}"
            if len(formatted["degree"]) + len(formatted["title"]) + len(institution)
            > 55
            and len(institution) < 30
            else institution
        )

        return formatted


class ExperienceItemGenerator(YamlTexModuleGenerator):
    item_type = "experience"

    def format_base(self, data: Data) -> FormattedFields:
        formatted = super().format_base(data)

        formatted["comment"] = format_optional(data["comment"])

        return formatted


class WorkItemGenerator(ExperienceItemGenerator):
    item_type = "work"


class CourseItemGenerator(YamlTexModuleGenerator):
    item_type = "course"


class ProjectItemGenerator(YamlTexModuleGenerator):
    item_type = "project"

    def format_fields_cv(self, data: Data) -> FormattedFields:
        formatted = super().format_fields_cv(data)

        link = data["link"]
        formatted["link"] = rf"Link: \showlink{{{link}}}" if link else ""

        return formatted

    def format_fields_resume(self, data: Data) -> FormattedFields:
        formatted = super().format_fields_resume(data)

        link = data["link"]
        formatted["link"] = rf"\href{{{link}}}{{{link}}}" if link else ""

        return formatted


class AwardItemGenerator(YamlTexModuleGenerator):
    item_type = "award"


class TexIdentityGenerator(FileToFileGenerator):
    def __init__(
        self,
        module_type: str,
        subdir: Optional[str] = None,
    ):
        formatters = {key: lambda x: x for key in FORMATS}
        super().__init__(module_type, formatters, subdir)

    def read(self, source: IO) -> Data:
        return {"tex": source.read()}

    def parse(self, data: Data) -> Data:
        return data

    def generate(self, parsed_data: Data, fmt: str) -> str:
        return parsed_data["tex"]

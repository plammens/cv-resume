import datetime
import functools
import logging
import os
from abc import ABCMeta, abstractmethod
from collections import defaultdict
from typing import Dict, IO, Optional, Sequence, Type, Union

import yaml

from .config import DATE_FIELDS, FORMATS, ITEMS_FIELD, ROOT_OUTPUT_PATH, TEXT_FIELDS
from .templates import TEX_TEMPLATES
from .save import save_tex
from .tokenize import tokenize
from .utils import (
    Data,
    FormattedFields,
    Formatter,
    format_date_long,
    format_date_short,
    format_optional,
    parse_date,
)


logger = logging.getLogger(__name__)


class AbstractTexModuleGenerator(metaclass=ABCMeta):
    def __init__(self, module_type: str, formatters: Dict[str, Formatter]):
        self.module_type = module_type
        self.formatters = formatters

    @abstractmethod
    def read(self, source: IO) -> Data:
        pass

    @abstractmethod
    def parse(self, data: Data) -> Data:
        pass

    @abstractmethod
    def generate(self, parsed_data: Data, fmt: str) -> str:
        pass

    @abstractmethod
    def save(self, generated_tex: str, *, name: str, fmt: str):
        pass


class FileToFileGenerator(AbstractTexModuleGenerator, metaclass=ABCMeta):
    def __init__(
        self,
        module_type: str,
        formatters: Dict[str, Formatter],
        subdir: Optional[str] = None,
    ):
        super().__init__(module_type, formatters)
        self.subdir = subdir if subdir is not None else self.module_type

    def save(self, generated_tex: str, *, name: str, fmt: str):
        save_tex(
            generated_tex,
            type_name=f"{fmt} TeX",
            name=name,
            output_dir=os.path.join(ROOT_OUTPUT_PATH, fmt, self.subdir),
        )

    def generate_file(self, path, add_comment=True):
        """Generate single file"""
        name = os.path.basename(path).rsplit(".")[0]
        logger.debug("%s processing %s (%s)", self.__class__.__name__, name, path)
        with open(path) as f:
            data = self.parse(self.read(f))
        for fmt in self.formatters:
            tex = self.generate(data, fmt)
            if add_comment:
                tex = f"% generated by {__file__} at {datetime.datetime.now()}\n" + tex
            self.save(tex, name=name, fmt=fmt)

    def generate_dir(self, source_dir: str, **kwargs) -> None:
        """Generate all files in a directory"""
        for file_name in os.listdir(source_dir):
            if os.path.isfile(path := os.path.join(source_dir, file_name)):
                self.generate_file(path, **kwargs)


class YamlTexModuleGenerator(FileToFileGenerator, metaclass=ABCMeta):
    def read(self, source):
        return yaml.full_load(source)

    def generate(self, parsed_data: Data, fmt: str) -> str:
        formatter = self.formatters[fmt]
        template = TEX_TEMPLATES[self.module_type][fmt]
        tex = template.fill(formatter(self.format_base(parsed_data)))
        return tex

    def parse(self, data: Data) -> Data:
        parsed = data.copy()
        fields = set(data.keys())
        for date_field in DATE_FIELDS & fields:
            parsed[date_field] = parse_date(data[date_field])
        for text_field in TEXT_FIELDS & fields:
            parsed[text_field] = tokenize(data[text_field])
        return parsed

    @staticmethod
    def format_base(parsed_data: Data) -> FormattedFields:
        formatted = parsed_data.copy()
        # replace None with empty string:
        for key, value in parsed_data.items():
            if value is None:
                formatted[key] = ""
        return formatted


def single_file_multiple_items(cls: Type[YamlTexModuleGenerator]):
    """
    Decorate a one-item-per-file generator into a multiple-items-per-file generator

    The generated output consists of the concatenation of the generated output for
    each individual item.
    """

    class DecoratedClass(YamlTexModuleGenerator):
        def __init__(self, *args, **kwargs):
            self.wrapped_generator = cls(*args, **kwargs)
            formatters = {
                fmt: lambda data: {
                    ITEMS_FIELD: [formatter(item) for item in data[ITEMS_FIELD]]
                }
                for fmt, formatter in self.wrapped_generator.formatters.items()
            }
            super().__init__(
                self.wrapped_generator.module_type,
                formatters,
                subdir="",  # single file for all items
            )

        def parse(self, data: Data) -> Data:
            items = data[ITEMS_FIELD]
            return {ITEMS_FIELD: [self.wrapped_generator.parse(item) for item in items]}

        def generate_dir(self, source_dir: str, **kwargs) -> None:
            raise TypeError(f"{cls.__name__} is a single-file-multiple-items generator")

    functools.update_wrapper(DecoratedClass, cls, updated=())
    return DecoratedClass


# ---------------- concrete subclasses -------------------


class ContactInfoGenerator(YamlTexModuleGenerator):
    def __init__(self):
        item_type = "contact-info"
        formatters = {"cv": self.format_generic, "resume": self.format_generic}
        super().__init__(item_type, formatters, subdir="")

    def parse(self, data: Data) -> Data:
        return data

    @staticmethod
    def format_generic(parsed_data: Data) -> FormattedFields:
        return parsed_data.copy()


class EducationItemGenerator(YamlTexModuleGenerator):
    def __init__(self):
        item_type = "education"
        formatters = {"cv": self.format_fields_cv, "resume": self.format_fields_resume}
        super().__init__(item_type, formatters)

    @staticmethod
    def format_fields_cv(data: Data) -> FormattedFields:
        formatted = data.copy()

        formatted["degree"] = format_optional(data["degree"])

        comment = data["comment"]
        formatted["comment"] = (
            f"Expected graduation: {comment['expected-end-date']}"
            if comment["expected-end-date"]
            else f"{comment['other']}"
        )

        for date_field in DATE_FIELDS:
            formatted[date_field] = format_date_long(data[date_field])

        return formatted

    @staticmethod
    def format_fields_resume(data: Data) -> FormattedFields:
        formatted = data.copy()

        formatted["degree"] = format_optional(data["degree"])

        comment = data["comment"]
        formatted["comment"] = (
            f"exp. {comment['expected-end-date']}"
            if comment["expected-end-date"]
            else f"{comment['other']}"
        )

        institution = data["institution"]
        formatted["institution"] = (
            rf" \newline {institution}"
            if len(data["degree"]) + len(data["title"]) + len(institution) > 55
            and len(institution) < 30
            else institution
        )

        for date_field in DATE_FIELDS:
            formatted[date_field] = format_date_short(data[date_field])

        return formatted


class WorkItemGenerator(YamlTexModuleGenerator):
    def __init__(self):
        item_type = "work"
        formatters = {"cv": self.format_fields_cv, "resume": self.format_fields_resume}
        super().__init__(item_type, formatters)

    @staticmethod
    def format_fields_cv(data: Data) -> FormattedFields:
        formatted = data.copy()

        formatted["comment"] = format_optional(data["comment"])

        for date_field in DATE_FIELDS:
            formatted[date_field] = format_date_long(data[date_field])

        return formatted

    @staticmethod
    def format_fields_resume(data: Data) -> FormattedFields:
        formatted = data.copy()

        formatted["optional"] = format_optional(data["comment"])

        for date_field in DATE_FIELDS:
            formatted[date_field] = format_date_short(data[date_field])

        return formatted


class TexIdentityGenerator(FileToFileGenerator):
    def __init__(
        self, module_type: str, subdir: Optional[str] = None,
    ):
        formatters = {key: lambda x: x for key in FORMATS}
        super().__init__(module_type, formatters, subdir)

    def read(self, source: IO) -> Data:
        return {"tex": source.read()}

    def parse(self, data: Data) -> Data:
        return data

    def generate(self, parsed_data: Data, fmt: str) -> str:
        return parsed_data["tex"]
